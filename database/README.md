# Minecraft Church Verification System - Database Schema

This directory contains the MySQL database schema for the Minecraft Church server verification and access control system.

## Files

- `schema.sql` - Complete database schema with all required tables
- `setup.sql` - Database initialization script (creates database if needed)

## Database Requirements

- MySQL 5.7+ or MariaDB 10.2+
- UTF8MB4 character set support
- InnoDB storage engine

## Quick Setup

1. **Create the database** (if it doesn't exist):
   ```sql
   CREATE DATABASE IF NOT EXISTS minecraft_church 
   CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
   ```

2. **Run the schema**:
   ```bash
   mysql -u your_username -p minecraft_church < schema.sql
   ```
   Or from MySQL client:
   ```sql
   USE minecraft_church;
   SOURCE schema.sql;
   ```

## Tables Overview

### `verification_codes`
Stores one-time 6-character codes generated by the Doorkeeper NPC. Codes expire after 15 minutes and are single-use.

**Key Fields:**
- `code` (PK) - 6-character code
- `child_name` - Minecraft username
- `expires_at` - Expiration timestamp
- `used_at` - When code was consumed (NULL if unused)

### `verification_requests`
Stores parent submissions from the Wix form. All requests start as `pending` and require manual admin approval.

**Key Fields:**
- `id` (PK) - Auto-increment ID
- `child_name` - Child's Minecraft username
- `adult_name` - Optional adult username
- `code` - Verification code used
- `status` - pending/approved/rejected/processed
- `approved_by` - Admin who approved/rejected

### `access_grants`
Stores approved grants that need to be applied via LuckPerms. The Denizen poller reads grants with `status='approved'` and applies them.

**Key Fields:**
- `id` (PK) - Auto-increment ID
- `request_id` (FK) - Links to verification_requests
- `player_name` - Player to grant access to
- `grant_type` - 'group' or 'permission'
- `grant_value` - Group name or permission node
- `status` - approved/applied/failed

### `known_players`
Tracks all players who have joined the server for audit purposes and platform detection.

**Key Fields:**
- `player_name` (PK) - Minecraft username
- `uuid` - Player UUID (may be NULL for Bedrock)
- `platform` - java/bedrock/unknown
- `first_seen_at` / `last_seen_at` - Timestamps

### `audit_log` (Optional)
Comprehensive audit trail of all administrative actions for compliance and debugging.

## Indexes

All tables include appropriate indexes for:
- Foreign key lookups
- Status filtering
- Time-based queries
- Player name searches

## Foreign Key Relationships

```
verification_codes (code)
    ↓
verification_requests (code) → access_grants (request_id)
                                    ↓
                            audit_log (request_id, grant_id)
```

## Data Types

- **VARCHAR(16)** - Minecraft usernames (max 16 characters)
- **VARCHAR(36)** - UUIDs (standard UUID format)
- **VARCHAR(6)** - Verification codes
- **VARCHAR(45)** - IP addresses (supports IPv6)
- **ENUM** - Status fields for type safety
- **TIMESTAMP** - All datetime fields use TIMESTAMP with automatic defaults

## Security Considerations

1. **Code Expiration**: Codes expire after 15 minutes (enforced by application logic)
2. **Single Use**: Codes are marked as used and cannot be reused
3. **Audit Trail**: All approvals are logged with admin identity and timestamp
4. **Foreign Keys**: CASCADE/SET NULL relationships prevent orphaned records

## Backup Recommendations

- Regular backups of all tables
- Especially important: `verification_requests` and `access_grants` for audit compliance
- Consider point-in-time recovery for compliance requirements

## Testing

After setup, verify tables exist:
```sql
SHOW TABLES;
DESCRIBE verification_codes;
DESCRIBE verification_requests;
DESCRIBE access_grants;
DESCRIBE known_players;
```

## Next Steps

1. Configure Apex API database connection (see step 2)
2. Set up API endpoints to interact with these tables
3. Configure Denizen scripts to poll and update grants
